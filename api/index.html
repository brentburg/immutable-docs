<!doctype html>
<html class="default no-js">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<title>immutable</title>
	<meta name="description" content="">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" href="assets/css/main.css">
	<script src="assets/js/modernizr.js"></script>
</head>
<body>
<header>
	<div class="tsd-page-toolbar">
		<div class="container">
			<div class="table-wrap">
				<div class="table-cell" id="tsd-search" data-index="assets/js/search.js" data-base=".">
					<div class="field">
						<label for="tsd-search-field" class="tsd-widget search no-caption">Search</label>
						<input id="tsd-search-field" type="text" />
					</div>
					<ul class="results">
						<li class="state loading">Preparing search index...</li>
						<li class="state failure">The search index is not available</li>
					</ul>
					<a href="index.html" class="title">immutable</a>
				</div>
				<div class="table-cell" id="tsd-widgets">
					<div id="tsd-filter">
						<a href="#" class="tsd-widget options no-caption" data-toggle="options">Options</a>
						<div class="tsd-filter-group">
							<input type="checkbox" id="tsd-filter-inherited" checked />
							<label class="tsd-widget" for="tsd-filter-inherited">Inherited</label>
							<input type="checkbox" id="tsd-filter-private" checked />
							<label class="tsd-widget" for="tsd-filter-private">Private</label>
							<input type="checkbox" id="tsd-filter-externals" checked />
							<label class="tsd-widget" for="tsd-filter-externals">Externals</label>
							<input type="checkbox" id="tsd-filter-only-exported" />
							<label class="tsd-widget" for="tsd-filter-only-exported">Only exported</label>
						</div>
					</div>
					<a href="#" class="tsd-widget menu no-caption" data-toggle="menu">Menu</a>
				</div>
			</div>
		</div>
	</div>
	<div class="tsd-page-title">
		<div class="container">
			<ul class="tsd-breadcrumb">
				<li>
					<a href="globals.html">Globals</a>
				</li>
			</ul>
			<h1> immutable</h1>
		</div>
	</div>
</header>
<div class="container container-main">
	<div class="row">
		<div class="col-8 col-content">
			<div class="tsd-panel tsd-typography">
				<h1 id="immutable-data-collections">Immutable Data Collections</h1>
				<p><strong>Converting to v3 from v2? Check out the <a href="https://github.com/facebook/immutable-js/wiki/Upgrading-to-Immutable-v3">upgrade guide</a>.</strong></p>
				<p>Immutable data cannot be changed once created, leading to much simpler
					application development, no defensive copying, and enabling advanced memoization
				techniques.</p>
				<p><code>Immutable</code> provides <code>List</code>, <code>Stack</code>, <code>Map</code>, <code>OrderedMap</code>, <code>Record</code>
					and <code>Set</code> by using persistent <a href="http://en.wikipedia.org/wiki/Hash_array_mapped_trie">hash maps tries</a>
					and <a href="http://hypirion.com/musings/understanding-persistent-vector-pt-1">vector tries</a>
					as popularized by Clojure and Scala. They achieve efficiency on modern
					JavaScript VMs by using structural sharing and minimizing the need to copy or
				cache data.</p>
				<p><code>Immutable</code> also provides a lazy <code>Seq</code>, allowing efficient
					chaining of collection methods like <code>map</code> and <code>filter</code> without creating
				intermediate representations. Create some <code>Seq</code> with <code>Range</code> and <code>Repeat</code>.</p>
				<h2 id="getting-started">Getting started</h2>
				<p>Install <code>immutable</code> using npm.</p>
				<pre><code class="lang-shell">npm install immutable
</code></pre>
				<p>Then require it into any module.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> Immutable = <span class="hljs-built_in">require</span>(<span class="hljs-string">'immutable'</span>);
<span class="hljs-keyword">var</span> map = Immutable.Map({a:<span class="hljs-number">1</span>, b:<span class="hljs-number">2</span>, c:<span class="hljs-number">3</span>});
</code></pre>
				<h3 id="browser">Browser</h3>
				<p>To use <code>immutable</code> from a browser, download <a href="./dist/immutable.min.js">dist/immutable.min.js</a>
					or use a CDN such as <a href="https://cdnjs.com/libraries/immutable">CDNJS</a>
				or <a href="http://www.jsdelivr.com/#!immutable.js">jsDelivr</a>.</p>
				<p>Then, add it as a script tag to your page:</p>
				<pre><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-title">script</span> <span class="hljs-attribute">src</span>=<span class="hljs-value">"immutable.min.js"</span>&gt;</span><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
<span class="hljs-tag">&lt;<span class="hljs-title">script</span>&gt;</span><span class="javascript">
    <span class="hljs-keyword">var</span> map = Immutable.Map({a:<span class="hljs-number">1</span>, b:<span class="hljs-number">2</span>, c:<span class="hljs-number">3</span>});
    map = map.set(<span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>);
    map.get(<span class="hljs-string">'b'</span>); <span class="hljs-comment">// 20</span>
</span><span class="hljs-tag">&lt;/<span class="hljs-title">script</span>&gt;</span>
</code></pre>
				<p>Or use an AMD loader (such as <a href="http://requirejs.org/">RequireJS</a>):</p>
				<pre><code class="lang-javascript"><span class="hljs-built_in">require</span>([<span class="hljs-string">'./immutable.min.js'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(Immutable)</span> </span>{
    <span class="hljs-keyword">var</span> map = Immutable.Map({a:<span class="hljs-number">1</span>, b:<span class="hljs-number">2</span>, c:<span class="hljs-number">3</span>});
    map = map.set(<span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>);
    map.get(<span class="hljs-string">'b'</span>); <span class="hljs-comment">// 20</span>
});
</code></pre>
				<p>If you&#39;re using <a href="http://browserify.org/">browserify</a>, the <code>immutable</code> npm module
				also works from the browser.</p>
				<h3 id="typescript">TypeScript</h3>
				<p>Use these Immutable collections and sequences as you would use native
					collections in your <a href="http://typescriptlang.org">TypeScript</a> programs while still taking
				advantage of type generics, error detection, and auto-complete in your IDE.</p>
				<p>Just add a reference with a relative path to the type declarations at the top
				of your file.</p>
				<pre><code class="lang-javascript"><span class="hljs-comment">///&lt;reference path='./node_modules/immutable/dist/Immutable.d.ts'/&gt;</span>
import Immutable = <span class="hljs-built_in">require</span>(<span class="hljs-string">'immutable'</span>);
<span class="hljs-keyword">var</span> map: Immutable.Map&lt;string, number&gt;;
map = Immutable.Map({a:<span class="hljs-number">1</span>, b:<span class="hljs-number">2</span>, c:<span class="hljs-number">3</span>});
map = map.set(<span class="hljs-string">'b'</span>, <span class="hljs-number">20</span>);
map.get(<span class="hljs-string">'b'</span>); <span class="hljs-comment">// 20</span>
</code></pre>
				<h2 id="the-case-for-immutability">The case for Immutability</h2>
				<p>Much of what makes application development difficult is tracking mutation and
					maintaining state. Developing with immutable data encourages you to think
				differently about how data flows through your application.</p>
				<p>Subscribing to data events throughout your application, by using
					<code>Object.observe</code>, or any other mechanism, creates a huge overhead of
					book-keeping which can hurt performance, sometimes dramatically, and creates
					opportunities for areas of your application to get out of sync with each other
					due to easy to make programmer error. Since immutable data never changes,
					subscribing to changes throughout the model is a dead-end and new data can only
				ever be passed from above.</p>
				<p>This model of data flow aligns well with the architecture of <a href="http://facebook.github.io/react/">React</a>
				and especially well with an application designed using the ideas of <a href="http://facebook.github.io/flux/docs/overview.html">Flux</a>.</p>
				<p>When data is passed from above rather than being subscribed to, and you&#39;re only
					interested in doing work when something has changed, you can use equality.
					<code>Immutable</code> always returns itself when a mutation results in an identical
					collection, allowing for using <code>===</code> equality to determine if something
				has changed.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> map1 = Immutable.Map({a:<span class="hljs-number">1</span>, b:<span class="hljs-number">2</span>, c:<span class="hljs-number">3</span>});
<span class="hljs-keyword">var</span> map2 = map1.set(<span class="hljs-string">'b'</span>, <span class="hljs-number">2</span>);
assert(map1 === map2);
</code></pre>
				<p>If an object is immutable, it can be &quot;copied&quot; simply by making another reference
					to it instead of copying the entire object. Because a reference is much smaller
					than the object itself, this results in memory savings and a potential boost in
				execution speed for programs which rely on copies (such as an undo-stack).</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> map1 = Immutable.Map({a:<span class="hljs-number">1</span>, b:<span class="hljs-number">2</span>, c:<span class="hljs-number">3</span>});
<span class="hljs-keyword">var</span> clone = map1;
</code></pre>
				<h2 id="javascript-first-api">JavaScript-first API</h2>
				<p>While <code>immutable</code> is inspired by Clojure, Scala, Haskell and other functional
					programming environments, it&#39;s designed to bring these powerful concepts to
					JavaScript, and therefore has an Object-Oriented API that closely mirrors that
					of ES6 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array">Array</a>,
					<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map">Map</a>, and
				<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set">Set</a>.</p>
				<p>The difference for the immutable collections is that methods which would mutate
					the collection, like <code>push</code>, <code>set</code>, <code>unshift</code> or <code>splice</code> instead return a new
					immutable collection. Methods which return new arrays like <code>slice</code> or <code>concat</code>
				instead return new immutable collections.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> list1 = Immutable.List.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);
<span class="hljs-keyword">var</span> list2 = list1.push(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>);
<span class="hljs-keyword">var</span> list3 = list2.unshift(<span class="hljs-number">0</span>);
<span class="hljs-keyword">var</span> list4 = list1.concat(list2, list3);
assert(list1.size === <span class="hljs-number">2</span>);
assert(list2.size === <span class="hljs-number">5</span>);
assert(list3.size === <span class="hljs-number">6</span>);
assert(list4.size === <span class="hljs-number">13</span>);
assert(list4.get(<span class="hljs-number">0</span>) === <span class="hljs-number">1</span>);
</code></pre>
				<p>Almost all of the methods on <code>Array</code> will be found in similar form on
					<code>Immutable.List</code>, those of <code>Map</code> found on <code>Immutable.Map</code>, and those of <code>Set</code>
					found on <code>Immutable.Set</code>, including collection operations like <code>forEach()</code>
				and <code>map()</code>.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> alpha = Immutable.Map({a:<span class="hljs-number">1</span>, b:<span class="hljs-number">2</span>, c:<span class="hljs-number">3</span>, d:<span class="hljs-number">4</span>});
alpha.map((v, k) =&gt; k.toUpperCase()).join();
<span class="hljs-comment">// 'A,B,C,D'</span>
</code></pre>
				<h3 id="accepts-raw-javascript-objects-">Accepts raw JavaScript objects.</h3>
				<p>Designed to inter-operate with your existing JavaScript, <code>immutable</code>
					accepts plain JavaScript Arrays and Objects anywhere a method expects an
				<code>Iterable</code> with no performance penalty.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> map1 = Immutable.Map({a:<span class="hljs-number">1</span>, b:<span class="hljs-number">2</span>, c:<span class="hljs-number">3</span>, d:<span class="hljs-number">4</span>});
<span class="hljs-keyword">var</span> map2 = Immutable.Map({c:<span class="hljs-number">10</span>, a:<span class="hljs-number">20</span>, t:<span class="hljs-number">30</span>});
<span class="hljs-keyword">var</span> obj = {d:<span class="hljs-number">100</span>, o:<span class="hljs-number">200</span>, g:<span class="hljs-number">300</span>};
<span class="hljs-keyword">var</span> map3 = map1.merge(map2, obj);
<span class="hljs-comment">// Map { a: 20, b: 2, c: 10, d: 100, t: 30, o: 200, g: 300 }</span>
</code></pre>
				<p>This is possible because <code>immutable</code> can treat any JavaScript Array or Object
					as an Iterable. You can take advantage of this in order to get sophisticated
					collection methods on JavaScript Objects, which otherwise have a very sparse
					native API. Because Seq evaluates lazily and does not cache intermediate
				results, these operations can be extremely efficient.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> myObject = {a:<span class="hljs-number">1</span>,b:<span class="hljs-number">2</span>,c:<span class="hljs-number">3</span>};
Seq(myObject).map(x =&gt; x * x).toObject();
<span class="hljs-comment">// { a: 1, b: 4, c: 9 }</span>
</code></pre>
				<h3 id="converts-back-to-raw-javascript-objects-">Converts back to raw JavaScript objects.</h3>
				<p>All <code>immutable</code> Iterables can be converted to plain JavaScript Arrays and
					Objects shallowly with <code>toArray()</code> and <code>toObject()</code> or deeply with <code>toJS()</code>.
					All Immutable Iterables also implement <code>toJSON()</code> allowing them to be passed to
				<code>JSON.stringify</code> directly.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> deep = Immutable.Map({ a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>, c: Immutable.List.of(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>) });
deep.toObject() <span class="hljs-comment">// { a: 1, b: 2, c: List [ 3, 4, 5 ] }</span>
deep.toArray() <span class="hljs-comment">// [ 1, 2, List [ 3, 4, 5 ] ]</span>
deep.toJS() <span class="hljs-comment">// { a: 1, b: 2, c: [ 3, 4, 5 ] }</span>
<span class="hljs-built_in">JSON</span>.stringify(deep) <span class="hljs-comment">// '{"a":1,"b":2,"c":[3,4,5]}'</span>
</code></pre>
				<h2 id="nested-structures">Nested Structures</h2>
				<p>The collections in <code>immutable</code> are intended to be nested, allowing for deep
				trees of data, similar to JSON.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> nested = Immutable.fromJS({a:{b:{c:[<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]}}});
<span class="hljs-comment">// Map { a: Map { b: Map { c: List [ 3, 4, 5 ] } } }</span>
</code></pre>
				<p>A few power-tools allow for reading and operating on nested data. The
					most useful are <code>mergeDeep</code>, <code>getIn</code>, <code>setIn</code>, and <code>updateIn</code>, found on <code>List</code>,
				<code>Map</code> and <code>OrderedMap</code>.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> nested2 = nested.mergeDeep({a:{b:{d:<span class="hljs-number">6</span>}}});
<span class="hljs-comment">// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 6 } } }</span>
</code></pre>
				<pre><code class="lang-javascript">nested2.getIn([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>]); <span class="hljs-comment">// 6</span>

<span class="hljs-keyword">var</span> nested3 = nested2.updateIn([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'d'</span>], value =&gt; value + <span class="hljs-number">1</span>);
<span class="hljs-comment">// Map { a: Map { b: Map { c: List [ 3, 4, 5 ], d: 7 } } }</span>

<span class="hljs-keyword">var</span> nested4 = nested3.updateIn([<span class="hljs-string">'a'</span>, <span class="hljs-string">'b'</span>, <span class="hljs-string">'c'</span>], list =&gt; list.push(<span class="hljs-number">6</span>));
<span class="hljs-comment">// Map { a: Map { b: Map { c: List [ 3, 4, 5, 6 ], d: 7 } } }</span>
</code></pre>
				<h2 id="lazy-seq">Lazy Seq</h2>
				<p><code>Seq</code> describes a lazy operation, allowing them to efficiently chain
				use of all the Iterable methods (such as <code>map</code> and <code>filter</code>).</p>
				<p><strong>Seq is immutable</strong> — Once a Seq is created, it cannot be
					changed, appended to, rearranged or otherwise modified. Instead, any mutative
				method called on a Seq will return a new Seq.</p>
				<p><strong>Seq is lazy</strong> — Seq does as little work as necessary to respond to any
				method call.</p>
				<p>For example, the following does not perform any work, because the resulting
				Seq is never used:</p>
				<pre><code><span class="hljs-reserved">var</span> oddSquares = Immutable.Sequence.<span class="hljs-keyword">of</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>)
  .filter(x <span class="hljs-function">=&gt;</span> x % <span class="hljs-number">2</span>).map(x <span class="hljs-function">=&gt;</span> x * x);
</code></pre><p>Once the Seq is used, it performs only the work necessary. In this
					example, no intermediate arrays are ever created, filter is called three times
				twice, and map is only called two times:</p>
				<pre><code>console.<span class="hljs-built_in">log</span>(oddSquares.<span class="hljs-built_in">get</span>(<span class="hljs-number">1</span>));<span class="hljs-comment"> // 9</span>
</code></pre><p>Any collection can be converted to a lazy Seq with <code>.toSeq()</code>.</p>
				<pre><code>var seq = Immutable.Map({a:<span class="hljs-number">1</span>, b:<span class="hljs-number">1</span>, c:<span class="hljs-number">1</span>}).toSe<span class="hljs-string">q()</span>;
</code></pre><p>Seq allow for the efficient chaining of sequence operations, especially when
				converting to a different concrete type (such as to a JS object):</p>
				<pre><code>seq.flip<span class="hljs-comment">()</span>.map<span class="hljs-comment">(key =&gt; key.toUpperCase()</span>).flip<span class="hljs-comment">()</span>.toObject<span class="hljs-comment">()</span>;
<span class="hljs-comment">// Map { A: 1, B: 1, C: 1 }</span>
</code></pre><p>As well as expressing logic that would otherwise seem memory-limited:</p>
				<pre><code>Immutable.Range(<span class="hljs-number">1</span>, Infinity)
  .skip(<span class="hljs-number">1000</span>)
  .map(n <span class="hljs-function">=&gt;</span> -n)
  .filter(n <span class="hljs-function">=&gt;</span> n % <span class="hljs-number">2</span> === <span class="hljs-number">0</span>)
  .take(<span class="hljs-number">2</span>)
  .reduce(<span class="hljs-function"><span class="hljs-params">(r, n)</span> =&gt;</span> r * n, <span class="hljs-number">1</span>);
<span class="hljs-regexp">//</span> <span class="hljs-number">1006008</span>
</code></pre><p>Note: An iterable is always iterated in the same order, however that order may
				not always be well defined, as is the case for the <code>Map</code>.</p>
				<h2 id="equality-treats-collections-as-data">Equality treats Collections as Data</h2>
				<p><code>Immutable</code> provides equality which treats immutable data structures as pure
				data, performing a deep equality check if necessary.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> map1 = Immutable.Map({a:<span class="hljs-number">1</span>, b:<span class="hljs-number">1</span>, c:<span class="hljs-number">1</span>});
<span class="hljs-keyword">var</span> map2 = Immutable.Map({a:<span class="hljs-number">1</span>, b:<span class="hljs-number">1</span>, c:<span class="hljs-number">1</span>});
assert(map1 !== map2);
assert(Immutable.is(map1, map2) === <span class="hljs-literal">true</span>);
</code></pre>
				<p><code>Immutable.is()</code> uses the same measure of equality as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is">Object.is</a>
					including if both are immutable and all keys and values are equal
				using the same measure of equality.</p>
				<h2 id="batching-mutations">Batching Mutations</h2>
				<blockquote>
					<p>If a tree falls in the woods, does it make a sound?</p>
					<p>If a pure function mutates some local data in order to produce an immutable
					return value, is that ok?</p>
					<p>— Rich Hickey, Clojure</p>
				</blockquote>
				<p>Applying a mutation to create a new immutable object results in some overhead,
					which can add up to a performance penalty. If you need to apply a series of
					mutations locally before returning, <code>Immutable</code> gives you the ability to create
					a temporary mutable (transient) copy of a collection and apply a batch of
					mutations in a performant manner by using <code>withMutations</code>. In fact, this is
				exactly how  <code>Immutable</code> applies complex mutations itself.</p>
				<p>As an example, building <code>list2</code> results in the creation of 1, not 3, new
				immutable Lists.</p>
				<pre><code class="lang-javascript"><span class="hljs-keyword">var</span> list1 = Immutable.List.of(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);
<span class="hljs-keyword">var</span> list2 = list1.withMutations(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(list)</span> </span>{
  list.push(<span class="hljs-number">4</span>).push(<span class="hljs-number">5</span>).push(<span class="hljs-number">6</span>);
});
assert(list1.size === <span class="hljs-number">3</span>);
assert(list2.size === <span class="hljs-number">6</span>);
</code></pre>
				<p>Note: <code>immutable</code> also provides <code>asMutable</code> and <code>asImmutable</code>, but only
					encourages their use when <code>withMutations</code> will not suffice. Use caution to not
				return a mutable copy, which could result in undesired behavior.</p>
				<h2 id="api-documentation">API Documentation</h2>
				<p>All documentation is contained within the type definition file, <a href="./type-definitions/Immutable.d.ts">Immutable.d.ts</a>.</p>
				<h2 id="contribution">Contribution</h2>
				<p>Use <a href="https://github.com/facebook/immutable-js/issues">Github issues</a> for requests.</p>
				<p>We actively welcome pull requests, learn how to <a href="./CONTRIBUTING.md">contribute</a>.</p>
				<h2 id="thanks">Thanks</h2>
				<p><a href="https://github.com/hughfdjackson/">Hugh Jackson</a>, for providing the npm package
				name. If you&#39;re looking for his unsupported package, see <a href="https://www.npmjs.org/package/immutable/1.4.1">v1.4.1</a>.</p>
				<p><a href="https://www.youtube.com/watch?v=K2NYwP90bNs">Phil Bagwell</a>, for his inspiration
				and research in persistent data structures.</p>
				<h2 id="license">License</h2>
				<p><code>Immutable</code> is <a href="./LICENSE">BSD-licensed</a>. We also provide an additional <a href="./PATENTS">patent grant</a>.</p>
			</div>
		</div>
		<div class="col-4 col-menu menu-sticky-wrap menu-highlight">
			<nav class="tsd-navigation primary">
				<ul>
					<li class="globals  ">
						<a href="globals.html"><em>Globals</em></a>
					</li>
					<li class=" tsd-kind-dynamic-module">
						<a href="modules/_immutable_.html">"immutable"</a>
					</li>
					<li class=" tsd-kind-container tsd-parent-kind-dynamic-module">
						<a href="modules/_immutable_.orderedmap.html">"immutable".<wbr>Ordered<wbr>Map</a>
					</li>
				</ul>
			</nav>
			<nav class="tsd-navigation secondary menu-sticky">
				<ul class="before-current">
				</ul>
			</nav>
		</div>
	</div>
</div>
<footer class="with-border-bottom">
	<div class="container">
		<h2>Legend</h2>
		<div class="tsd-legend-group">
			<ul class="tsd-legend">
				<li class="tsd-kind-container"><span class="tsd-kind-icon">Container, dynamic module</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-enum"><span class="tsd-kind-icon">Enumeration</span></li>
				<li class="tsd-kind-enum-member"><span class="tsd-kind-icon">Enumeration member</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-object-literal"><span class="tsd-kind-icon">Object literal</span></li>
				<li class="tsd-kind-construct-signature"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property"><span class="tsd-kind-icon">Variable</span></li>
				<li class="tsd-kind-call-signature"><span class="tsd-kind-icon">Function, call signature, accessor</span></li>
				<li class="tsd-kind-index-signature"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-interface"><span class="tsd-kind-icon">Interface</span></li>
				<li class="tsd-kind-construct-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-interface"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Member, accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-interface"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li class="tsd-kind-class"><span class="tsd-kind-icon">Class</span></li>
				<li class="tsd-kind-construct-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class"><span class="tsd-kind-icon">Property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Member, accessor</span></li>
				<li class="tsd-kind-index-signature tsd-parent-kind-class"><span class="tsd-kind-icon">Index signature</span></li>
			</ul>
			<ul class="tsd-legend">
				<li>&nbsp;</li>
				<li class="tsd-kind-construct-signature tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-inherited"><span class="tsd-kind-icon">Inherited member</span></li>
			</ul>
			<ul class="tsd-legend">
				<li>&nbsp;</li>
				<li class="tsd-kind-construct-signature tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private constructor</span></li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-private"><span class="tsd-kind-icon">Private member</span></li>
			</ul>
			<ul class="tsd-legend">
				<li>&nbsp;</li>
				<li>&nbsp;</li>
				<li class="tsd-kind-property tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static property</span></li>
				<li class="tsd-kind-call-signature tsd-parent-kind-class tsd-is-static"><span class="tsd-kind-icon">Static member</span></li>
			</ul>
		</div>
	</div>
</footer>
<div class="container tsd-generator">
	<p>Generated using <a href="http://typedoc.io" target="_blank">TypeDoc</a></p>
</div>
<div class="overlay"></div>
<script src="assets/js/main.js"></script>
<script>if (location.protocol == 'file:') document.write('<script src="assets/js/search.js"><' + '/script>');</script>
</body>
</html>